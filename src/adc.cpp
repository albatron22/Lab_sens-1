#include <avr/io.h>
#include <avr/interrupt.h>

#include "adc.h"


ISR(ADC_vect) 
{
 int a=(ADCW+1)/128;
 if (a == 0) 
 PORTB=0x00;
 else 
 PORTB = 1 << (a-1);
}


//ADC Init - Инициализурем АЦП. Это можно сунуть куда - нибудь в начало кода
//Итак что тут у нас:
//ADEN = 1 - разрешаем АЦП
//ADIE = 1Разрешаем прерывания. 
//ADSC = 1 Запускаем преобразование (первое, дальше автоматом)
//ADATE = 1 Непрерывные последовательные преобразования, одно за другим.
//ADPS2..0 = 3 Делитель частоты на 8 - так у меня получается оптимальная частота.

void adc_init(){
	ADCSRA|=(1<<ADEN)|(0<<ADIE)|(1<<ADSC)|(0<<ADATE)|(3<<ADPS0);

	ADMUX = 0b01000000;
//А тут выбираем откуда брать будем сигнал
//REFS -- 0b[01]000101 первые два бита - напряжение с входа AVCC
//ADLAR --0b01[1]00101следующий бит выравнивание по левому краю
//MUX -- 0b010[00000]</B>Сигнал на вход идет с нулевого канала АЦП.
	sei();

}


uint16_t adc_get_value(void){
	ADCSRA|=(1<<ADSC); //запускаем преобразование
	while((ADCSRA & (1<<ADIF))==0);
	ADCSRA&=~(1<<ADIF); //сброс флага завершения преобразования АЦП
	uint16_t adc_value = ADCL|(ADCH<<8);
	return adc_value;


}
