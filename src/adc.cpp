#include <avr/io.h>
#include <avr/interrupt.h>

#include "adc.h"

ISR(ADC_vect)
{
    int a = (ADCW + 1) / 128;
    if (a == 0)
        PORTB = 0x00;
    else
        PORTB = 1 << (a - 1);
}

//ADC Init - Инициализурем АЦП. Это можно сунуть куда - нибудь в начало кода
//Итак что тут у нас:
//ADEN = 1 - разрешаем АЦП
//ADIE = 1Разрешаем прерывания.
//ADSC = 1 Запускаем преобразование (первое, дальше автоматом)
//ADATE = 1 Непрерывные последовательные преобразования, одно за другим.
//ADPS2..0 = 3 Делитель частоты на 8 - так у меня получается оптимальная частота.

void adc_init()
{
    
    ADCSRA |= (1 << ADEN) | (0 << ADIE) | (1 << ADSC) | (0 << ADATE) | (3 << ADPS0);

    ADMUX = 0b01000000;
    //А тут выбираем откуда брать будем сигнал
    //REFS -- 0b[01]000101 первые два бита - напряжение с входа AVCC
    //ADLAR --0b01[1]00101следующий бит выравнивание по левому краю
    //MUX -- 0b010[00000]</B>Сигнал на вход идет с нулевого канала АЦП.
    sei();
}

uint16_t adc_get_value(void)
{
    ADCSRA |= (1 << ADSC); //запускаем преобразование
    while ((ADCSRA & (1 << ADIF)) == 0)
        ;
    ADCSRA &= ~(1 << ADIF); //сброс флага завершения преобразования АЦП
    uint16_t adc_value = ADCL | (ADCH << 8);
    return adc_value;
}
